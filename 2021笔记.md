## html

### 1.实现一个大小为父元素一半的正方形
    利用padding值的单位为百分比的话，是以父级元素的宽作为参考的。
```css
.outer {
    width: 300px;
    height: 500px;
}
.inner {
    width: 50%;
    padding-bottom: 50%;
}
```

## js基础

### 1.列举你所知道的类型判断的方法？
- typeof： 同样是引用类型 数组和函数的判断分别是 object function，所以不准确
- instanceof: 可能会被修改
```js
class PrimitiString {
    static [Symbol.hasInstance](x) {
        return typeof x === 'string'
    }
}
// 实现instanceof
function myInstanceof(left, right) {
    const prototype = right.prototype
    left = left.__proto__
    // left是不是能够在原型链上找到right.prototype
    while(true) {
        if (left === null || left === undefined ) return false
        if (left === prototype) return true
        left = left.__proto__
    }
}
```
- constructor判断： 对于null 和undefined 无法判断

最终方案：Object.protoType.toString
```js
function isType(item, type) {
    return Object.prototype.toString.call(item) === [`object ${type}`]
}
```

### 2.深拷贝
使用JSON.parse(JSON.stringify(xxx))进行深拷贝的局限性：
- 会忽略undefined和symbol和函数
- 对于循环引用直接报错

自己实现简单的deepClone

```js
function deepClone(obj) {
    if (['number', 'string', 'undefined'].includes(typeof obj) || !obj) return obj;
    const newObj = Array.isArray(obj) ? [...obj] : {...obj}

    Reflect.ownKeys(newObj).forEach(key => {
        newObj[key] = Object.prototype.toString.call(obj[key]) === '[object Object]' ? deepClone(obj[key]) : obj[key]
    })

    return newObj
}
```

### 3.实现一个精准的setInterval

```js
function setInterval(callback, interval) {
    let timer, startTime, endTime;
    const now = Date.now;
    startTime = endTime = now()

    function loop() {
        timer = requestAnimationFrame(loop);
        endTime = now()
        if (start - endTime > interval) {
            startTime = endTime = now()
            callback(timer)
        }
    }

    timer = requestAnimationFrame(loop)

    return timer;
}
```

### 4.
